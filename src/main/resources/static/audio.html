<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amplitude History Recorder</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        canvas { background: #000; border: 1px solid #444; border-radius: 4px; margin-bottom: 10px; }
        .controls { display: flex; gap: 10px; margin-bottom: 20px; }
        button { padding: 8px 16px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        button:hover { background: #444; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .stats { font-family: monospace; font-size: 14px; color: #aaa; }
    </style>
</head>
<body>

<h2>Amplitude History (RMS)</h2>

<!-- Canvas for drawing the scrolling graph -->
<canvas id="graphCanvas" width="800" height="200"></canvas>

<div class="controls">
    <button id="btnStart">Start Mic</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnExport" disabled>Export Data (JSON)</button>
    <button id="btnClear">Clear Graph</button>
</div>

<div class="stats" id="stats">Avg Volume: 0.00 | Max: 0.00</div>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnExport = document.getElementById('btnExport');
    const btnClear = document.getElementById('btnClear');
    const statsEl = document.getElementById('stats');

    let audioContext, analyser, microphone, scriptProcessor;
    let isRecording = false;
    let amplitudeHistory = []; // Stores the volume levels
    const maxHistory = 400;    // Number of points to keep on screen

    // Draw the initial grid
    drawGraph();

    btnStart.onclick = async () => {
        try {
            // 1. Setup Audio Context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // 2. Get Mic Input
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphone = audioContext.createMediaStreamSource(stream);

            // 3. Setup Analyser (Standard node)
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            // 4. Setup ScriptProcessor (or AudioWorklet) for processing loop
            // We use ScriptProcessor here for simplicity in a single file,
            // though AudioWorklet is the modern standard for heavy lifting.
            const bufferSize = 2048;
            scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);

            // Connect nodes: Mic -> Analyser -> ScriptProcessor -> Destination
            microphone.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(audioContext.destination);

            // 5. Process Audio Frames
            scriptProcessor.onaudioprocess = function(audioProcessingEvent) {
                if (!isRecording) return;

                // Get raw waveform data (values between -1 and 1)
                const inputBuffer = audioProcessingEvent.inputBuffer;
                const inputData = inputBuffer.getChannelData(0);

                // --- CALCULATE RMS (Root Mean Square) ---
                let sum = 0;
                for (let i = 0; i < inputData.length; i++) {
                    sum += inputData[i] * inputData[i];
                }
                let rms = Math.sqrt(sum / inputData.length);

                // Amplify slightly for better visibility (optional)
                // rms usually is very small (0.01 - 0.5)
                const displayValue = Math.min(rms * 5, 1.0);

                // Store in history
                amplitudeHistory.push({
                    timestamp: Date.now(),
                    value: rms,            // raw value
                    display: displayValue  // scaled value for drawing
                });

                // Keep array size manageable for drawing
                if (amplitudeHistory.length > maxHistory) {
                    amplitudeHistory.shift();
                }

                drawGraph();
                updateStats(rms);
            };

            isRecording = true;
            btnStart.disabled = true;
            btnStop.disabled = false;
            btnExport.disabled = true; // Disable export while recording (optional)

        } catch (err) {
            console.error("Error accessing microphone:", err);
            alert("Microphone access denied or error occurred.");
        }
    };

    btnStop.onclick = () => {
        isRecording = false;
        if (audioContext) audioContext.close();
        btnStart.disabled = false;
        btnStop.disabled = true;
        btnExport.disabled = false;
    };

    btnClear.onclick = () => {
        amplitudeHistory = [];
        drawGraph();
    };

    btnExport.onclick = () => {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(amplitudeHistory));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "amplitude_data.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    };

    function drawGraph() {
        // Clear background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Grid Lines
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height / 2); // Center line
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();

        if (amplitudeHistory.length === 0) return;

        // Draw Amplitude Line
        ctx.beginPath();
        ctx.strokeStyle = '#0f0'; // Green line
        ctx.lineWidth = 2;

        // The width of each slice
        const sliceWidth = canvas.width / maxHistory;

        for (let i = 0; i < amplitudeHistory.length; i++) {
            const x = i * sliceWidth;
            // height is based on the display value (0 to 1)
            // We draw it mirrored around the center (like an envelope)
            const height = amplitudeHistory[i].display * (canvas.height / 2);

            // Draw top half
            if (i === 0) ctx.moveTo(x, (canvas.height / 2) - height);
            else ctx.lineTo(x, (canvas.height / 2) - height);
        }
        ctx.stroke();

        // Optional: Draw filled area
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.lineTo(0, canvas.height / 2);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fill();
    }

    function updateStats(currentRms) {
        // Simple smoothing for text display
        statsEl.innerText = `RMS: ${currentRms.toFixed(4)} | History Len: ${amplitudeHistory.length}`;
    }
</script>
</body>
</html>
